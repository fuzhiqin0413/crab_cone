% Cone create algorithm

%%% Check that output match what is generated by python code

%%% Large error on two theta slices, 1 degree recurring on many slices...

clear
clc
close all

% Load in angle data
dataFolder = '/Users/gavintaylor/Documents/Company/Client Projects/Cones MPI/Data/liquid angle csv/800nm_thick';

% Convert to mm
voxelSize = 800/10^6;

scaleSteps = 800/voxelSize/10^6;

% Load theta angles
thetaVolume = loadcsvstack(sprintf('%s/theta', dataFolder), 0);

% Load phi angles
phiVolume = loadcsvstack(sprintf('%s/phi', dataFolder), 0);

volumeSize = size(phiVolume);

%% Get radius profile from image - unclear what function used to set that.
% This is effectively 'radii_scaled', post interpolation
close all

radiusList = zeros(volumeSize(3),1);

for i = 1:volumeSize(3)
    inds = find(~isnan(thetaVolume(:,:,i)) | ~isnan(phiVolume(:,:,i)));
    
    [tempX, tempY] = ind2sub(volumeSize(1:2), inds);
    
    radiusList(i) = (max(sqrt((tempX-volumeSize(1)/2).^2 + (tempY-volumeSize(2)/2).^2))); 
    
end

% Modified! To match Oliver code, radius to big.
radiusList = radiusList - 1;

radiusList = floor(radiusList);

figure;
plot(radiusList)

%%% dimensions, scaling, slice select etc
orig_dimension = 300;
voxel_size_nm = 800;
% only change the wanted resolution input to make changes in your model fineness
resolution_nm = 800;
scaling = voxel_size_nm/resolution_nm;
dimension = orig_dimension*scaling;
half_pitch_nm = 2000;
angle_step = 180/(half_pitch_nm/resolution_nm);
angle_step_inv = 360/angle_step;
reset_zero = 360/angle_step;

[x, y] = meshgrid(0:(dimension-1), 0:(dimension-1));
x = x(:); y = y(:);

z = 1:volumeSize(3);

cx = dimension/2;
cy = dimension/2;

%% Create phi map as in radius code

testPhiVolume = zeros(volumeSize);

sliceDiff = zeros(length(radiusList), 1);

for i = 1:length(radiusList)
    
    tempSlice = zeros(volumeSize(1:2))*NaN;

    % Essentially this steps in from outer radius...
    for j = 0:(radiusList(i)-1) 
        maskInds = find((x-cx).^2 + (y-cy).^2 < (radiusList(i)-j)^2);
        
        tempSlice(maskInds) = mod((angle_step*j),360)+0.0002;
    end
    
    noNoiseInds = find((x-cx).^2 + (y-cy).^2 > radiusList(i)^2);
        
    tempSlice(noNoiseInds) = 0;
        
    testPhiVolume(:,:,i) = tempSlice; 
    
    temp = phiVolume(:,:,i) - tempSlice;
    
    sliceDiff(i) = max( abs(temp(:)));
end

figure; subplot(2,2,1);
imshow(phiVolume(:,:,10)/360)

subplot(2,2,2);
imshow(testPhiVolume(:,:,10)/360)

subplot(2,2,3);
imshow(testPhiVolume(:,:,10)-phiVolume(:,:,10)) 

subplot(2,2,4);
plot(sliceDiff)

% Clean up, small values to zero, zerso to Nan
testPhiVolume(testPhiVolume == 0) = NaN;

testPhiVolume(abs(testPhiVolume) < 1) = 0;

testPhiVolume = int16(testPhiVolume);

%% Test building Theta array
%%% This does not match exactly, often difference of 1 degree
% However, I think this may be calculated more accurately

warning('Still bad on two levels')

testThetaVolume = zeros(volumeSize);

sliceDiff = zeros(length(radiusList), 1);

figure; 
for i = 1:length(radiusList)
    
    tempSlice = zeros(volumeSize(1:2))*NaN;

    % Essentially this steps in from outer radius...
    firstRing = round(radiusList(i)*0.73);
    for j = 0:(radiusList(i)-firstRing-1)
        maskInds = find((x-cx).^2 + (y-cy).^2 < (radiusList(i)-j)^2);
        
        tempSlice(maskInds) = asin( sin( (2*pi/(angle_step_inv))*j ));
    end
    
    % Constant or offset?
    offset1 = (radiusList(i)-firstRing)*(2*pi/angle_step_inv);
    
    secondRing = round(radiusList(i)*0.2);
    for j = 1:(firstRing - secondRing-1) 
        maskInds = find((x-cx).^2 + (y-cy).^2 < (firstRing-j)^2);
        
        tempSlice(maskInds) = asin( sin( (2*pi/(angle_step_inv))*j + offset1)) / ...
            (1+(j/angle_step_inv));
    end
    
    offset2 = asin(sin(2*pi/angle_step_inv*(firstRing-secondRing) + offset1)) / ...
        (1+(firstRing-secondRing)/angle_step_inv);
    
    for j = 1:(secondRing - 1) 
        maskInds = find((x-cx).^2 + (y-cy).^2 < (secondRing-j)^2);
        
        tempSlice(maskInds) = asin(sin(offset2))/j;
    end
    
%     for i in range (0,radius-round(radius*0.73)):           
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i))))
%         stetigkeit_1 = (radius-round(radius*0.73))*(2*math.pi/angle_step_inv)
%     for i in range (1,((round(radius*0.73))-round(radius*0.2))):           
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.73)-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i)+stetigkeit_1)))/(1+(i/angle_step_inv))
%         stetigkeit_2 = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*(round(radius*0.73)-round(radius*0.2)))+stetigkeit_1)))/(1+((round(radius*0.73)-round(radius*0.2))/angle_step_inv))
%     for i in range (1,(round(radius*0.2))): 
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.2)-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(stetigkeit_2)))/i
    
    noNoiseInds = find((x-cx).^2 + (y-cy).^2 > radiusList(i)^2);
        
    tempSlice(noNoiseInds) = 0;
        
    % Changed
    tempSlice = round(tempSlice/pi*180);
    
    testThetaVolume(:,:,i) = tempSlice; 
    
    temp = thetaVolume(:,:,i) - tempSlice;
    
    sliceDiff(i) = max( abs(temp(:)));
%     
%     subplot(1,3,1);
%     imshow((tempSlice+90)/180)
% 
%     subplot(1,3,2);
%     imshow((thetaVolume(:,:,i)+90)/180)
% 
%     subplot(1,3,3);
%     imshow((tempSlice-thetaVolume(:,:,i) + 2)/4) 
end

figure; subplot(2,2,1);
imshow((thetaVolume(:,:,166)+90)/180)

subplot(2,2,2);
imshow((testThetaVolume(:,:,166)+90)/180)

subplot(2,2,3);
imshow((testThetaVolume(:,:,166)-thetaVolume(:,:,166) + 2) / 4) 

subplot(2,2,4);
plot(sliceDiff)

% Clean up, small values to zero, zerso to Nan
testThetaVolume(testThetaVolume == 0) = NaN;

testThetaVolume(abs(testThetaVolume) < 1) = 0;

testThetaVolume = int16(testThetaVolume);

% ### build the theta array
% slice_theta = np.zeros((y.size,x.size))
% counter = -1
% for i in range(len(radii_scaled)):
%     damn = i
%     counter += 1
%     radius = round(radii_scaled[i])
%     cx = dimension/2
%     cy = dimension/2      
%     #for i in range (0,(radius-int(radius*0.73))):
%     #    mask_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
%     #    arr_theta[mask_i] = (angle_step*i)%360
%     for i in range (0,radius-round(radius*0.73)):           
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i))))
%         stetigkeit_1 = (radius-round(radius*0.73))*(2*math.pi/angle_step_inv)
%     for i in range (1,((round(radius*0.73))-round(radius*0.2))):           
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.73)-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i)+stetigkeit_1)))/(1+(i/angle_step_inv))
%         stetigkeit_2 = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*(round(radius*0.73)-round(radius*0.2)))+stetigkeit_1)))/(1+((round(radius*0.73)-round(radius*0.2))/angle_step_inv))
%     for i in range (1,(round(radius*0.2))): 
%         mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.2)-i)**2)
%         slice_theta[mask_increase_i] = (math.asin(math.sin(stetigkeit_2)))/i
%     nonoise = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 > radius**2)
%     slice_theta[nonoise] = 0
%     slice_theta_deg=np.rad2deg(slice_theta)
%     init_ar_theta[:,:,damn] = slice_theta_deg    
%     output = Image.fromarray(slice_theta_deg)                                                           
%     output.save(workfolder+subfolder+'tifs/theta/'+ str(damn) +'.tif') 
% 
% array_theta = init_ar_theta
% array_theta[array_theta==0.0] = 1000
% array_theta[(array_theta>-1)&(array_theta<1)] = 0
% array_theta = array_theta.astype(int)
%  
% exp_array_theta[:,:,:] = array_theta
% exp_array_theta[exp_array_theta==1000] = '-'