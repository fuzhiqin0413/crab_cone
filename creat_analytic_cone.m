% Cone create algorithm

% Take radius from image, unclear what function used to set that.

%%% Check that images match what is generated by python code

slice_phi = np.zeros((x.size,y.size)) 
counter = -1 # counter for first level for-loop (not needed now, but used in 'inside out script' for increment in central layer)
for i in range(len(radii_scaled)):
    damn = i
    counter += 1
    radius = int(radii_scaled[i])
    cx = dimension/2
    cy = dimension/2  
    for i in range (0,radius):   
        mask_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
        slice_phi[mask_i] = (angle_step*i)%360+0.0002
        nonoise_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 > radius**2)
        slice_phi[nonoise_i] = 0
    init_ar_phi[:,:,damn] = slice_phi    
    output = Image.fromarray(slice_phi)                                                           
    output.save(workfolder+subfolder+'tifs/phi/'+ str(damn) +'.tif') 

# this is to clean up the volume with values that can be changed for the csv export (remaining zeros from 'air' are set to 1000, the 0.0002 are set to zero)
array_phi = init_ar_phi 
array_phi[array_phi==0] = 1000
array_phi[(array_phi>-1)&(array_phi<1)] = 0
array_phi = array_phi.astype(int)

exp_array_phi[:,:,:] = array_phi
exp_array_phi[exp_array_phi==1000] = '-'
    
# save each slice in single csv for Gavin's matlab import
for i in range (0, new_len):
    np.savetxt(workfolder +subfolder+ 'phi/'+str(i)+'.csv', exp_array_phi[:,:,i], delimiter=",", fmt='%s') 
### build the phi array

                                        
### build the theta array
slice_theta = np.zeros((y.size,x.size))
counter = -1
for i in range(len(radii_scaled)):
    damn = i
    counter += 1
    radius = round(radii_scaled[i])
    cx = dimension/2
    cy = dimension/2      
    #for i in range (0,(radius-int(radius*0.73))):
    #    mask_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
    #    arr_theta[mask_i] = (angle_step*i)%360
    for i in range (0,radius-round(radius*0.73)):           
        mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (radius-i)**2)
        slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i))))
        stetigkeit_1 = (radius-round(radius*0.73))*(2*math.pi/angle_step_inv)
    for i in range (1,((round(radius*0.73))-round(radius*0.2))):           
        mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.73)-i)**2)
        slice_theta[mask_increase_i] = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*i)+stetigkeit_1)))/(1+(i/angle_step_inv))
        stetigkeit_2 = (math.asin(math.sin(((2*math.pi/(angle_step_inv))*(round(radius*0.73)-round(radius*0.2)))+stetigkeit_1)))/(1+((round(radius*0.73)-round(radius*0.2))/angle_step_inv))
    for i in range (1,(round(radius*0.2))): 
        mask_increase_i = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 < (round(radius*0.2)-i)**2)
        slice_theta[mask_increase_i] = (math.asin(math.sin(stetigkeit_2)))/i
    nonoise = ((x[np.newaxis,:]-cx)**2 + (y[:,np.newaxis]-cy)**2 > radius**2)
    slice_theta[nonoise] = 0
    slice_theta_deg=np.rad2deg(slice_theta)
    init_ar_theta[:,:,damn] = slice_theta_deg    
    output = Image.fromarray(slice_theta_deg)                                                           
    output.save(workfolder+subfolder+'tifs/theta/'+ str(damn) +'.tif') 

array_theta = init_ar_theta
array_theta[array_theta==0.0] = 1000
array_theta[(array_theta>-1)&(array_theta<1)] = 0
array_theta = array_theta.astype(int)
 
exp_array_theta[:,:,:] = array_theta
exp_array_theta[exp_array_theta==1000] = '-'